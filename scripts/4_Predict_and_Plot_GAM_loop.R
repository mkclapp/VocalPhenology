# This code iterates across species and elevation bins to fit GAMs for vocal activity (daily rates of birdnet detections).
# The inputs are zero-filled datasets generated by script "2_prep_data_for_HGAM.R" which vary by the precision thresholds applied to the BirdNET output (options: [none], 0.90, 0.95, or 0.99). Due to file upload constraints on the paper submission portal, we are unable to provide that script or its inputs. We are happy to provide that data and code upon request.

# The GAM as currently specified:
        # uses all data (does not attempt to filter to presumed-occupied sites)
        # truncates all "Mid" elevation models to begin at JDay 120 (only one location recorded prior to that in the Mids)


# Load libraries and input files
library(tidyverse)
library(mgcv)
library(gratia)
library(zoo)


load(file="input/Zerofill_Sets_20251107.RData") # zero filled sets for different precision thresholds (no threshold="allspp", 0.90="trials.0fill.090", 0.95="trials.0fill.095", and 0.99="trials.0fill.099")

# choose which thresholded dataset to use, set "thresh" accordingly
# NAs are present in all of the thresholded datasets due to the extremely low precision of btyw-- no btyw made it past a 0.90 pr(TP)
bin0 <- trials.0fill.095[!is.na(trials.0fill.095$threshold),]
thresh <- "0.95"
# mcgv doesn't like characters, convert to factors
bin0$location <- as.factor(bin0$location)
bin0$aou4 <- as.factor(bin0$aou4)
bin0$ElevBin <- factor(bin0$ElevBin, levels=c("Low","Mid"))

# truncate Mid data to day 120
bin0.occ <- bin0[!(bin0$ElevBin=="Mid" & bin0$JDay<120),] 

bin0.occ %>% group_by(aou4, ElevBin) %>% summarise(nhits=sum(nhits))# %>% View()

# set region
region <- "OLYM"


# FOR LOOP ------------------------------------------------------------

species.list <- as.character(sort(unique(bin0.occ$aou4)))
elev.bin <- as.character(sort(unique(bin0.occ$ElevBin)))
spline_type <- "tp"

# initialize data frame where phenometrics will be stored
export.stats <- data.frame(
  species = NULL,
  elev.bin = NULL,
  metric = NULL,
  jday = NULL
)


# Empty list to store a list of models
mod.list <- list()

# Start plotting PDF 
pdf(file = paste0("./output/model_output/SpeciesPlotsElev_",region,"_", spline_type, "_ALLDATA_28spp_k=7_maxperc=0.3_pred_by_spp_thresh=",thresh, "_", Sys.Date(),".pdf"), width = 8.5, height = 11)
par(mfrow = c(4, 2))

# runtime several minutes. 

for(i in 1:length(species.list)) {
  for(j in 1:length(elev.bin)) {
    # Model for species i in elevational bin j in region k (region = OLYM vs SINE)
    data.ijk <- bin0.occ[bin0.occ$aou4 == tolower(species.list[i]) & bin0.occ$ElevBin == elev.bin[j], ]
    # Make sure we have enough data to continue
    if(dim(data.ijk)[1] > 0 & length(unique(data.ijk$location)) > 4) {
      # Fit GAM model
      model.ijk <- gam(
        cbind(nhits, ntrials) ~ s(JDay, bs = "tp", k = 7) + s(location, bs = "re"),
        data = data.ijk,
        method = "REML",
        family = binomial(link = "logit"),
        knots = list(JDay = c(50,300)) # make starting and ending knots way before and after breeding season (50=20 Feb; 300=28 Oct)
      )
      # store model in mod.list
      mod.list[[paste(toupper(data.ijk$aou4[1]),data.ijk$ElevBin[1],sep="_")]] <- model.ijk
      
      # Extract phenometrics
      new_data <- data.frame(JDay = seq(summary(bin0.occ$JDay[bin0.occ$ElevBin==elev.bin[j] & bin0.occ$aou4==species.list[i]])[[1]], summary(bin0.occ$JDay[bin0.occ$ElevBin==elev.bin[j] & bin0.occ$aou4==species.list[i]])[[6]]), 
                             location = data.ijk$location[1]) # dummy location to satisfy predict()
      predictions <- predict(model.ijk, newdata = new_data,
                             type="link",
                             se.fit = T,
                             exclude = 's(location)')
      # standard errors
      critval <- 1.96 ## approx 95% CI
      
      predictions$fit.trans <- model.ijk$family$linkinv(predictions$fit)
      predictions$upr.trans <- model.ijk$family$linkinv(predictions$fit + (critval * predictions$se.fit))
      predictions$lwr.trans <- model.ijk$family$linkinv(predictions$fit - (critval * predictions$se.fit))
      
      # Finding mins / maxes
      pred.zoo <- as.zoo(predictions$fit.trans)
      min.days <- new_data$JDay[which(rollapply(pred.zoo, width = 9, FUN = function(x) which.min(x)==5)) + 4]
      max.days <- new_data$JDay[which(rollapply(pred.zoo, width = 9, FUN = function(x) which.max(x)==5)) + 4]

      # Test for a max at the start and/or end if starting/ending is > 30% of max probability elsewhere
      start.max <- as.vector(predictions$fit.trans[1] > 0.3*max(predictions$fit.trans))
      end.max <- as.vector(predictions$fit.trans[length(predictions$fit.trans)] > 0.3*max(predictions$fit.trans))
      # Eliminate max values that are not > 30% of the global max
      max.days <- max.days[predictions$fit.trans[new_data$JDay %in% max.days] > 0.3*max(predictions$fit.trans)]
      # vector including boundaries if applicable
      all.max <- c(if(start.max == T) {min(new_data$JDay)} else {NULL},
                   max.days,
                   if(end.max == T) {max(new_data$JDay)} else {NULL})
      # vector that only includes min if min is between maxes
      all.min <- min.days[min.days < max(all.max) & min.days > min(all.max)]
      # Only calculate half-max if there are non-boundary maxes  
      half.rise <- NULL
      half.fall <- NULL
      if(length(max.days) > 0) {
        for(k in 1:length(max.days)) {
          # calculate half-rise for every non-boundary max
          # calculated as half-y between max and preceding min
          max.k <- max.days[k]
          if(min(min.days) < min(max.k)) {
            min.k <- min.days[max(which(min.days < max.k))]
          } else {
            min.k <- min(new_data$JDay) # if min at previous edge, select edge
          }
          
          half.y <- mean(c(predictions$fit.trans[new_data$JDay == max.k],
                           predictions$fit.trans[new_data$JDay == min.k]))
          half.rise.k <- new_data$JDay[as.numeric(attr(which.min(abs((predictions$fit.trans - half.y)[which(new_data$JDay == min.k):which(new_data$JDay == max.k)])), "names"))]
         
          # calculate half-fall for every non-boundary max
          # calculated as half-y between max and following min
          if(max(min.days) > max.k) {
            min.k <- min.days[min(which(min.days > max.k))]
          } else {
            min.k <- max(new_data$JDay) # if min at next edge, select edge
          }
          half.y <- mean(c(predictions$fit.trans[new_data$JDay == max.k],
                           predictions$fit.trans[new_data$JDay == min.k]))
          half.fall.k <- new_data$JDay[as.numeric(attr(which.min(abs((predictions$fit.trans - half.y)[which(new_data$JDay == max.k):which(new_data$JDay == min.k)])), "names"))]
          
          # save in object
          half.rise <- c(half.rise, half.rise.k)
          half.fall <- c(half.fall, half.fall.k)
        }
      }

      # Export data.frame
      df.ijk <- rbind(if(length(min.days) > 0) {data.frame(species = toupper(species.list[i]),
                                       elev.bin = elev.bin[j],
                                       metric = "Minimum", 
                                       jday = min.days)},
                      if(start.max == TRUE) {data.frame(species = toupper(species.list[i]),
                                                        elev.bin = elev.bin[j],
                                                        metric = "Start Boundary", 
                                                        jday = min(new_data$JDay))},
                      if(end.max == TRUE) {data.frame(species = toupper(species.list[i]),
                                                      elev.bin = elev.bin[j],
                                                      metric = "End Boundary", 
                                                      jday = max(new_data$JDay))},
                      if(length(max.days) > 0) {rbind(
                        data.frame(species = toupper(species.list[i]),
                                                           elev.bin = elev.bin[j],
                                                           metric = "Maximum", 
                                                           jday = max.days),
                        data.frame(species = toupper(species.list[i]),
                                   elev.bin = elev.bin[j],
                                   metric = "Half Rise", 
                                   jday = half.rise),
                        data.frame(species = toupper(species.list[i]),
                                   elev.bin = elev.bin[j],
                                   metric = "Half Fall", 
                                   jday = half.fall))
                        }
                      )
      # Store this species/bin into export data.frame
      export.stats <- rbind(export.stats, df.ijk)
      
      # Create plot
      plot(new_data$JDay, predictions$fit.trans, type = "l", xlab = "Day of Year", ylab = "Predicted Frequency of Vocalization",
           ylim = c(0, max(predictions$upr.trans)*1.1),
           xlim = range(bin0.occ$JDay),
           main = paste(toupper(species.list[i]), "in", elev.bin[j]), lwd = 2)
      lines(new_data$JDay, predictions$upr.trans)
      lines(new_data$JDay, predictions$lwr.trans)
      points(data.ijk$JDay, ((data.ijk$nhits / data.ijk$ntrials)/ max((data.ijk$nhits / data.ijk$ntrials)))*max(predictions$fit.trans), pch = 16, col = "#00000020")
      abline(v = all.min, col = "red")
      abline(v = all.max, col = "blue")
      abline(v = half.rise, col = "green")
      abline(v = half.fall, col = "green")
    }
  }
}
dev.off() 

## Export CSV of metrics
write.csv(x = export.stats, file = paste0("./output/model_output/Phenometrics_",region,"_",spline_type, "_ALLDATA_k=7_maxperc=0.3_pred_by_spp_thresh=",thresh, "_", Sys.Date(), ".csv"))

saveRDS(mod.list, file = paste0("./output/model_output/mod.list", region,spline_type, "_ALLDATA_k=7_maxperc=0.3_pred_by_spp_thresh=", thresh, "_", Sys.Date(), ".rds"))

# model summaries ---------------------------------------------------------
# Initialize an empty data frame to store results
results <- data.frame(
  model_name = character(),
  edf_jday = numeric(),
  ref_df_jday = numeric(),
  p_value_jday = numeric(),
  edf_location = numeric(),
  ref_df_location = numeric(),
  p_value_location = numeric(),
  deviance_explained = numeric(),
  n = integer(),
  stringsAsFactors = FALSE
)

# Loop through each model in mod.list
for (model_name in names(mod.list)) {
  # Extract the current model
  model <- mod.list[[model_name]]
  
  # Get the summary of the model
  model_summary <- summary(model)
  
  # Extract information for JDay (assuming it's the first smooth term)
  edf_jday <- model_summary$s.table[1, "edf"]
  ref_df_jday <- model_summary$s.table[1, "Ref.df"]
  p_value_jday <- model_summary$s.table[1, "p-value"]
  
  # Extract information for Location (assuming it's the random smooth term)
  edf_location <- model_summary$s.table[2, "edf"] # Adjust index if needed
  ref_df_location <- model_summary$s.table[2, "Ref.df"]
  p_value_location <- model_summary$s.table[2, "p-value"]
  
  # Extract deviance explained and sample size (n)
  deviance_explained <- model_summary$dev.expl
  n <- length(model$y) # Number of observations
  
  # Add the values to the results data frame
  results <- rbind(
    results, 
    data.frame(
      model_name = model_name,
      edf_jday = round(edf_jday,3),
      ref_df_jday = round(ref_df_jday,3),
      p_value_jday = round(p_value_jday,3),
      edf_location = round(edf_location,3),
      ref_df_location = ref_df_location,
      p_value_location = round(p_value_location,3),
      deviance_explained = round(deviance_explained,3),
      n = n,
      stringsAsFactors = FALSE
    )
  )
}

# Print the results
print(results)

loc_data <- read_csv("./input/OLYM_final_locdata.csv")

loc_data$ElevBin <- factor(loc_data$ElevBin, levels=c("Low", "Mid", "High"))

# filter to models w/ elev overlap and sufficient data

nhits.results <- trials.0fill.095 %>% left_join(loc_data) %>% filter(ElevBin !="High") %>% mutate(species=toupper(aou4), elev.bin=ElevBin, keep="unused") %>% group_by(species, elev.bin) %>% summarise(nhits = sum(nhits)) %>% filter(!is.na(species))

nhits.results %>% group_by(elev.bin) %>% summarise(n_distinct(species))
mod.results <- results %>% separate(model_name, into = c("species", "elev.bin"), sep="_") %>% left_join(nhits.results)

write.csv(mod.results, paste0("./output/model_output/gam.mod.results_", Sys.Date(), ".csv"))

save(species.list, loc_data, nhits.results, export.stats, mod.results, file="./output/model_output/multispecies_GAM_results.RData")
